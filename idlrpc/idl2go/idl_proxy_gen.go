package main

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
)

const (
	stdef = `// Generated by the go idl tools. DO NOT EDIT {{idltime}}
// source: {{.Service.Name}}

{{- $idln := .Idlname}}

package {{tolower .Service.Name}}

import (
	"fmt"

	"{{$idln}}/idldata"
	pbdata "{{$idln}}/idldata/pbdata"
	"gitee.com/dennis-kk/rpc-go-backend/idlrpc"
	"gitee.com/dennis-kk/rpc-go-backend/idlrpc/pkg/errors"
	"gitee.com/dennis-kk/rpc-go-backend/idlrpc/pkg/transport"
	"google.golang.org/protobuf/proto"
)

// define stub.ProxyStub 
type {{.Service.Name}}Proxy struct{
	idlrpc.ProxyBase
}

func {{.Service.Name}}ProxyCreator(trans transport.ITransport) idlrpc.IProxy {
	if trans == nil {
		return nil
	}

	if trans.IsClose() {
		return nil
	}
	
	srvProxy := &{{.Service.Name}}Proxy{}
	srvProxy.SetTransport(trans)

	return srvProxy
}

// define function
func (sp *{{.Service.Name}}Proxy) GetUUID() uint64{
	return SrvUUID
}

func (sp *{{.Service.Name}}Proxy) GetSrvName() string {
	return SrvName
}

func (sp *{{.Service.Name}}Proxy) GetSignature(methid uint32) string {
	var sign string
	switch methid{
		{{- range .Service.Methods}}
		case {{.Index}}:
			sign = "{{.Name}}"
		{{- end}}
	}
	return sign
}

func (sp *{{.Service.Name}}Proxy) IsOneWay(methodid uint32) (isoneway bool){
	switch methodid{
		{{- range .Service.Methods}}
		case {{.Index}}:
			isoneway = {{.IsOneway}}
		{{- end}}
		default:
			isoneway = false
	}
	return
}


{{- $sn := .Service.Name}}
{{- range .Service.Methods}}
func(sp *{{$sn}}Proxy){{stfieldup .Name}}({{- range $index,$elem := .Arguments}}
{{- if $index }}{{print ", "}}{{end}} 
{{- if ne $elem.GoType "void" }}
{{- "_"}}{{$elem.Index}}{{- block "typelet" $elem}}{{end}}
{{- end}}
{{- end}})({{if .RetType}}{{if ne .RetType.GoType "void" }}ret1 {{block "typelet" .RetType}}{{end}},{{end}}{{end}}err error){

	rpc := sp.GetRpc()
	if rpc == nil {
		//TODO add define error
		return
	}
	
	{{- if isupper .Name }}
	pbarg := &pbdata.{{$sn}}_{{stfieldup .Name}}Args{
	}
	{{- else }}
	pbarg := &pbdata.{{$sn}}{{stfieldup .Name}}Args{
	}
	{{- end }}
	
	{{- range .Arguments }}
	{{- if ne .IdlType "void"}}
	{{- if eq .IdlType "i8" "i16"}}
	pbarg.Arg{{.Index}} = int32(_{{.Index}})
	{{- else if eq .IdlType "ui8" "ui16"}}
	pbarg.Arg{{.Index}} = uint32(_{{.Index}})
	{{- else if eq .IdlType "set" }}
	for k, _ := range _{{.Index}} {
		pbarg.Arg{{.Index}} = append(pbarg.Arg{{.Index}}, k)
	}
	{{- else if eq .IdlType "seq"}}
	for _,v := range _{{.Index}} {
		{{- if .Key.IsStruct}}
		if v != nil {
			pbarg.Arg{{.Index}} = append(pbarg.Arg{{.Index}}, v.SerializeToPb())
		}
		{{- else}}
		pbarg.Arg{{.Index}} = append(pbarg.Arg{{.Index}}, v)
		{{- end}}
	}
	{{- else if eq .IdlType "dict"}}
	if _{{.Index}} != nil{
		pbarg.Arg{{.Index}} = make(map[{{.Key.GoType}}]{{if .Value.IsStruct}}*pbdata.{{end}}{{.Value.GoType}})
	}
	for k,v := range _{{.Index}} {
		{{- if .Value.IsStruct}}
		if v != nil{
			pbarg.Arg{{.Index}}[k] = v.SerializeToPb()
		}
		{{- else}}
		pbarg.Arg{{.Index}}[k] = v
		{{- end}}
	}
	{{- else if .IsStruct}}
	if _{{.Index}} != nil{
		pbarg.Arg{{.Index}} = _{{.Index}}.SerializeToPb()
	}
	{{- else if .IsEnum}}
		pbarg.Arg{{.Index}} = pbdata.{{.GoType}}(_{{.Index}})
	{{- else}}
	pbarg.Arg{{.Index}} = _{{.Index}}
	{{- end}}
	{{- end}}
	{{- end}}

	{{- if eq .RetType.IdlType "void"}}
		_, err = rpc.Call(sp, {{.Index}}, {{.TimeOut}}, {{.Retry}}, pbarg)
	{{- else}}
		respMsg, err := rpc.Call(sp, {{.Index}}, {{.TimeOut}}, {{.Retry}}, pbarg)
	{{- end}}
	if err != nil && err != errors.ErrRpcRet {
		return
	}
	
{{if not .IsOneway }}
	{{- if ne .RetType.IdlType "void"}}
	//如果是oneway 的方法 不用检测返回值序列化，相当于传统的调用
	{{- if isupper .Name }}
	pbret := &pbdata.{{$sn}}_{{stfieldup .Name}}Ret{}
	{{- else }}
	pbret := &pbdata.{{$sn}}{{stfieldup .Name}}Ret{}
	{{- end }}
	perr := proto.Unmarshal(respMsg, pbret)
	if perr != nil {
		return ret1, perr
	}
	var pbCtxInfo map[string]string
	if pbret.Ctx != nil {
		pbCtxInfo = pbCtxInfoToMap(pbret.Ctx.Info)
	}
	if err == errors.ErrRpcRet {
		trace, ok := pbCtxInfo["call_trace"]
		errmsg := pbCtxInfo["error_info"]
		if ok && sp.GetRpc().Options().CallTrace() {
			panic(fmt.Sprintf("call trace =====> RPC CALL PANIC: %s\n%s\n<=====", errmsg, trace))
		}
		err = fmt.Errorf("%w: %s", err, errmsg)
	}
		{{- if eq .RetType.IdlType "i8" "i16" "ui8" "ui16"}}	
	ret1 = {{.RetType.GoType}}(pbret.Ret1)
		{{- else if eq .RetType.IdlType "set" }}
	for _, v := range pbret.Ret1 {
		ret1[v]=true
	}
		{{- else if eq .RetType.IdlType "seq"}}
	for _,v := range pbret.Ret1 {
		{{- if .RetType.Key.IsStruct}}
		obj := &idldata.{{.RetType.Key.GoType}}{}
		obj.ParseFromPb(v)
		ret1 = append(ret1, obj)
		{{- else}}
		ret1 = append(ret1, {{.RetType.Key.GoType}}(v))
		{{- end}}
	}
		{{- else if eq .RetType.IdlType "dict"}}
	if ret1 == nil {
		ret1 = make(map[{{.RetType.Key.GoType}}]{{if .RetType.Value.IsStruct}}*idldata.{{end}}{{.RetType.Value.GoType}})
	}
	for k,v := range pbret.Ret1 {
		{{- if .RetType.Value.IsStruct}}
		temp := &idldata.{{.RetType.Value.GoType}}{}
		temp.ParseFromPb(v)
		ret1[k] = temp
		{{- else}}
		ret1[k] = {{.RetType.Value.GoType}}(v)
		{{- end}}
	}
		{{- else if .RetType.IsStruct}}
	if pbret.Ret1 != nil {
		ret1 = &idldata.{{.RetType.GoType}}{}
		ret1.ParseFromPb(pbret.Ret1)
	}
		{{- else if .RetType.IsEnum}}
	ret1 = idldata.{{.RetType.GoType}}(pbret.Ret1)
		{{- else }}
	ret1 = pbret.Ret1
		{{- end}}
	{{- end}}
{{end}}
	return
}
{{- end}}

func pbCtxInfoToMap(info []*pbdata.KeyValue) map[string]string {
	m := make(map[string]string)
	if info == nil {
		return m
	}
	for _, kv := range info {
		m[kv.Key] = kv.Value
	}
	return m
}
`
	gProxyPath = "proxy"
)

var (
	proxytp *template.Template
)

func init() {
	temptp, err := template.New("proxy").Funcs(funcsMap).Parse(stdef)
	if err != nil {
		panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
	}
	temptp, err = temptp.Parse(funcletter)
	if err != nil {
		panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
	}

	proxytp, err = temptp.Parse(typeletter)
	if err != nil {
		panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
	}
}

func GenProxyFile(idlname string, gen *Gen) error {
	if gen == nil {
		return errors.New("gen idl name info error !!!!")
	}

	if proxytp == nil {
		panic("proxy template impl error read nil value  !!! ")
	}

	////生成每个服务生成自己的impl数据
	//if PathExits(gProxyPath) == false {
	//	err := os.Mkdir(gProxyPath, 0755)
	//	if err != nil {
	//		return err
	//	}
	//}
	//
	//err := os.Chdir(gProxyPath)
	//if err != nil {
	//	fmt.Printf("change to impl dir error %v dir %s \n", err, gProxyPath)
	//	return err
	//}
	//
	//defer os.Chdir("../")

	idlpackagename = "idldata"
	defer func() {
		idlpackagename = ""
	}()

	//检测文件删了重写
	ifile := strings.ToLower(gen.Name) + "_proxy.go"
	if FileExits(ifile) {
		//存在的话删了重新生成
		err := os.Remove(ifile)
		if err != nil {
			fmt.Printf("delete %s impl file error %v !!! \n", gen.Name, err)
			return err
		}
	}

	//打开文件
	filehanle, err := os.OpenFile(ifile, os.O_WRONLY|os.O_CREATE, 0765)
	if err != nil {
		return err
	}

	defer filehanle.Close()

	err = proxytp.Execute(filehanle, gen)
	if err != nil {
		fmt.Printf("generate imple file error %v\n", err)
		return err
	}

	//回退目录
	return nil
}
