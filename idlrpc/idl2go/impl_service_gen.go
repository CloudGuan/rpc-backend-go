package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"strings"
	"sync"
	"text/template"
)

//client impl 修正
const (
	clientlex = `// Generated by the go idl tools. DO NOT EDIT {{idltime}}
// source: {{.Idlname}}
package {{tolower .Service.Name}}_impl

import idldata "{{.Idlname}}/idldata"
import "{{.Idlname}}/{{tolower .Service.Name}}"
import "context"
import "fmt"

type {{.Service.Name}}Impl struct{
}

func New{{.Service.Name}}() *{{.Service.Name}}Impl{
	service := &{{.Service.Name}}Impl{
	}
	return service
}

{{- $sn := .Service.Name}}

func (sp *{{$sn}}Impl)GetUUID() uint64{
return {{tolower .Service.Name}}.SrvUUID
}

func (sp *{{$sn}}Impl) GetNickName() string {
	return fmt.Sprintf("%d", {{tolower .Service.Name}}.SrvUUID)
}

func (sp *{{$sn}}Impl)OnAfterFork(ctx context.Context) bool {
	//add this service to framework, do not call rpc method in this function 
	return true
}

func (sp *{{$sn}}Impl) OnTick() bool {
	//tick function in main goroutine
	return true
}

func (sp *{{$sn}}Impl) OnBeforeDestroy() bool {
	//tick function in main goroutine
	return true
}


{{- range .Service.Methods}}
func(sp *{{$sn}}Impl){{stfieldup .Name}}(ctx context.Context{{- range $index,$elem := .Arguments}}
{{- print ", "}} 
{{- if ne $elem.GoType "void" }}
{{- with $elem.DeclName }}{{$elem.DeclName}}{{else}}{{- "_"}}{{$elem.Index}}{{end}}{{- block "typelet" $elem}}{{end}}
{{- end}}
{{- end}})({{if .RetType}}{{if ne .RetType.GoType "void" }}ret1 {{block "typelet" .RetType}}{{end}},{{end}}{{end}}err error){
	return
}
{{end}}
`
)

var (
	clienttp *template.Template
	once     sync.Once
)

func init() {
	once.Do(func() {
		temptp, err := template.New("stub").Funcs(funcsMap).Parse(clientlex)
		if err != nil {
			fmt.Printf("%v\n", err)
			panic(fmt.Sprintf("init stub letter error %v !!!!", err))
		}
		temptp, err = temptp.Parse(funcletter)
		if err != nil {
			panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
		}

		clienttp, err = temptp.Parse(typeletter)
		if err != nil {
			panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
		}

	})
}

func GenClientImpl(idlname string, gen *Gen) error {
	if gen == nil {
		return errors.New("Idl Name Gen Error" + idlname)
	}

	if PathExits("usr") == false {
		err := os.Mkdir("usr", 0755)
		if err != nil {
			return err
		}
	}

	err := os.Chdir("usr")
	if err != nil {
		return err
	}
	idlpackagename = "idldata"
	defer func() {
		os.Chdir("../")
		idlpackagename = ""
	}()

	//检测文件删了重写
	ifile := strings.ToLower(gen.Name) + "_impl.go"
	if FileExits(ifile) {
		//存在的话删了重新生成
		err := os.Remove(ifile)
		if err != nil {
			fmt.Printf("delete %s impl file error %v !!! \n", gen.Name, err)
			return err
		}
	}

	//打开文件
	filehanle, err := os.OpenFile(ifile, os.O_WRONLY|os.O_CREATE, 0765)
	if err != nil {
		return err
	}

	defer func() {
		filehanle.Close()
	}()

	err = clienttp.Execute(filehanle, gen)
	if err != nil {
		fmt.Printf("generate client impl file error %v\n", err)
		return err
	}

	if err = GenClientImplMod(gen); err != nil {
		return err
	}

	return nil
}

func GenClientImplMod(gen *Gen) error {
	filename := "go.mod"
	if FileExits(filename) {
		//存在的话删了重新生成
		err := os.Remove(filename)
		if err != nil {
			fmt.Printf("delete %s idl common file  error %v !!! \n", filename, err)
			return err
		}
	}

	hfile, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE, 0765)
	if err != nil {
		fmt.Printf("Open Idl %s Common Struct Error  %v!!!!", filename, err)
		return err
	}

	defer hfile.Close()

	//没啥东西直接写就好了
	var codec bytes.Buffer

	codec.WriteString("// Machine generated code\n\n")
	codec.WriteString("// Code generated by go-idl-tool.\n")
	codec.WriteString(fmt.Sprintf("//date: %s \n//idltool version: %s \n//source: %s \n \n", TimeFormat(), toolVersion, gen.Idlname))

	codec.WriteString(`module ` + gen.Idlname + "/" + strings.ToLower(gen.Name) + "_impl")
	codec.WriteString("\n")
	codec.WriteString(`go 1.16`)
	codec.WriteString("\n\n")

	idlName := strings.ToLower(gen.Idlname)
	serviceName := strings.ToLower(gen.Name)

	requireinfo := fmt.Sprintf("require (\n"+
		"%s/idldata v0.0.0"+
		"\n%s/%s v0.0.0"+
		"\n)", idlName, idlName, serviceName)

	codec.WriteString(requireinfo)
	codec.WriteString("\n\n") //路径替换这里需要替换对应基础包的路径
	codec.WriteString(fmt.Sprintf("replace (\n"+
		"%s/idldata => ../../../../src/pkg/%s/idldata"+
		"\n%s/%s => ../../../../src/pkg/%s/%s"+
		"\n)", idlName, idlName, idlName, serviceName, idlName, serviceName))
	_, _ = hfile.WriteString(codec.String())
	return nil
}
