package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
)

//@title gen service impl
//@desc 生成实现方法 一个文件只有一个 实现对应的接口
//基本格式 type service interface {
//	method1()
//	method2()
//}

const (
	//impl interface 模板
	implletter = `
// Generated by the go idl tools. DO NOT EDIT {{idltime}}
// source: {{.Service.Name}}
package {{tolower .Service.Name}}

import(
	"gitee.com/dennis-kk/rpc-go-backend/idlrpc"
	"{{.Idlname}}/idldata"
	"context"
)

const(
	SrvUUID = {{.Service.Uuid}}
	SrvName = "{{.Service.Name}}"
)

type I{{.Service.Name}} interface{
	idlrpc.IService
{{- block "methods" .Service.Methods}}{{"\n"}}
{{- range .}}{{println .Name}}{{end}}
{{- end}}
}
`
)

var (
	impltp *template.Template
)

//使用letter 进行初始化
func init() {
	temptp, err := template.New("impl").Funcs(funcsMap).Parse(implletter)
	if err != nil {
		panic(fmt.Sprintf("init implment letter error %v !!!!", err))
	}
	impltp, err = template.Must(temptp.Clone()).Parse(funcletter)
	if err != nil {
		panic(fmt.Sprintf("init implment letter error %v !!!!", err))
	}
	impltp, err = impltp.Parse(typeletter)
	if err != nil {
		panic(fmt.Sprintf("init implment letter error %v !!!!", err))
	}
}

func GenImplMod(idlname, srvname string) error {
	//文件已经存在删除
	if FileExits("go.mod") {
		//存在的话删了重新生成
		err := os.Remove("go.mod")
		if err != nil {
			return err
		}
	}

	var codec bytes.Buffer
	moduledef := fmt.Sprintf("module %s/%s", strings.ToLower(idlname), strings.ToLower(srvname))
	codec.WriteString(moduledef)
	codec.WriteString("\n\n")
	codec.WriteString("go 1.16")
	codec.WriteString("\n\n")

	codec.WriteString(`require (`)
	codec.WriteString("\n")
	codec.WriteString(idlname + "/idldata" + ` v0.0.0` + "\n\t")
	// 如果是v0.0.0 则使用本地版本替换
	codec.WriteString("gitee.com/dennis-kk/rpc-go-backend " + gVersion)
	codec.WriteString("\n\tgithub.com/golang/protobuf v1.4.3\n\tgoogle.golang.org/protobuf v1.23.0")
	codec.WriteString("\n)\n")
	codec.WriteString(`replace (`)
	codec.WriteString("\n")
	codec.WriteString(idlname + "/idldata" + " => ../idldata" + "\n")
	if gVersion == "v0.0.0" {
		codec.WriteString("gitee.com/dennis-kk/rpc-go-backend => ../../../../framework/rpc-go-backend")
	}
	codec.WriteString("\n)")

	hfile, err := os.OpenFile("go.mod", os.O_WRONLY|os.O_CREATE, 0765)
	if err != nil {
		fmt.Printf("Open Idl %s Common Struct Error  %v!!!!", "go.mod", err)
		return err
	}

	defer hfile.Close()
	hfile.WriteString(codec.String())

	return nil
}

func GenServiceImpl(srv_name string, gen *Gen) error {
	//service and stub generate in root path
	//if PathExits(gImplPath) == false {
	//	os.Mkdir(gImplPath, 765)
	//}
	//
	//err := os.Chdir(gImplPath)
	//if err != nil {
	//	fmt.Printf("change to impl dir error %v dir %s \n", err, gImplPath)
	//	return err
	//}
	//
	//defer os.Chdir("../")

	if impltp == nil {
		return errors.New("impl template is nil")
	}

	if gen == nil {
		return errors.New("srv is nil !!!!")
	}
	//检测文件是否存在
	ifile := strings.ToLower(srv_name) + "_def.go"
	if FileExits(ifile) {
		//存在的话删了重新生成
		err := os.Remove(ifile)
		if err != nil {
			fmt.Printf("delete %s impl file error %v !!! \n", srv_name, err)
			return err
		}
	}

	idlpackagename = "idldata"
	defer func() {
		idlpackagename = ""
	}()
	//打开文件
	filehanle, err := os.OpenFile(ifile, os.O_WRONLY|os.O_CREATE, 0765)
	if err != nil {
		return err
	}

	defer filehanle.Close()

	err = impltp.Execute(filehanle, gen)
	if err != nil {
		fmt.Printf("generate imple file error %v\n", err)
		return err
	}

	//生成结构
	return nil
}
