package main

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"text/template"
)

const (
	stubLetter = `// Machine generated code
// Code generated by go-idl-tool. DO NOT EDIT {{idltime}}
// source: {{.Service.Name}}

{{- $idln := .Idlname}}

package {{tolower .Service.Name}}

import (
	"errors"
	"context"
	"fmt"
	"runtime/debug"

	pbdata "{{$idln}}/idldata/pbdata"
	"{{$idln}}/idldata"
	"gitee.com/dennis-kk/rpc-go-backend/idlrpc"
	rpcerr "gitee.com/dennis-kk/rpc-go-backend/idlrpc/pkg/errors"
	"github.com/golang/protobuf/proto"
)

type {{.Service.Name}}Stub struct{
	srvImpl I{{.Service.Name}}
}

func New{{.Service.Name}}Stub(srvImpl I{{.Service.Name}}) *{{.Service.Name}}Stub {
	return &{{.Service.Name}}Stub{
		srvImpl,
	}
}

func {{.Service.Name}}StubCreator(v interface{}) idlrpc.IStub{
	if service, ok := v.(I{{.Service.Name}}); ok {
		return &{{.Service.Name}}Stub{
			service,
		}
	}
	return nil
}


func (sb *{{.Service.Name}}Stub) GetUUID() idlrpc.SvcUuid {
	return SrvUUID
}

func (sb *{{.Service.Name}}Stub) GetServiceName() string {
	return SrvName
}


func (sb *{{.Service.Name}}Stub) GetSignature(methodid uint32) string {
	var sign string
	switch methodid {
		{{- range .Service.Methods}}
		case {{.Index}}:
			sign = "{{.Name}}"
		{{- end}}
	}
	return sign
}


func (sb *{{.Service.Name}}Stub) GetMutipleNum() uint32 {
	return {{.Service.MaxInst}}
}

func (sb *{{.Service.Name}}Stub)  OnAfterFork(ctx context.Context) bool{
	return sb.srvImpl.OnAfterFork(ctx)
}

func (sb *{{.Service.Name}}Stub)  OnTick() bool{
	return sb.srvImpl.OnTick()
}

func (sb *{{.Service.Name}}Stub)  OnBeforeDestroy() bool{
	return sb.srvImpl.OnBeforeDestroy()
}

func (sb *{{.Service.Name}}Stub) GetStatus() idlrpc.ServiceStatus{
	return idlrpc.SERVICE_RESOLVED
}

func (sb *{{.Service.Name}}Stub) SetStatus(status idlrpc.ServiceStatus){
}

func (sb *{{.Service.Name}}Stub) Call(ctx context.Context, methodId uint32,  req []byte) (resp []byte, err error) {
	//解析header
	switch methodId {
	{{- range .Service.Methods}}
		case {{.Index}}:
			resp, err = sb.{{stfieldup .Name}}(ctx, req)
	{{- end}}
	default:
		err = errors.New("Method Not Fount!!!!!")
	}
	return
}

func (sb *{{.Service.Name}}Stub)IsOneWay(methodid uint32)(isoneway bool) {
		switch methodid{
		{{- range .Service.Methods}}
		case {{.Index}}:
			isoneway = {{.IsOneway}}
		{{- end}}
		default:
			isoneway = false
	}
	return
}

{{- $sn := .Service.Name}}
{{range .Service.Methods}}
{{- $fcn := stfieldup .Name}}
func(sb *{{$sn}}Stub) {{$fcn}}(ctx context.Context, req []byte) (resp []byte, err error){
	
	if sb == nil {
		err = errors.New(SrvName + "Service is not Regist")
		return
	}

	if req == nil {
		err = errors.New("Request Function Is InValid")
		return
	}

	//解包协议
	{{- if isupper .Name }}
	pbreq := &pbdata.{{$sn}}_{{$fcn}}Args{}
	{{- else}}
	pbreq := &pbdata.{{$sn}}{{$fcn}}Args{}
	{{- end}}
	err = proto.Unmarshal(req, pbreq)
	if err != nil {
		return
	}
	{{range .Arguments}}
	{{- if ne .IdlType "void" }}
	{{- if eq .IdlType "i8" "i16" "ui8" "ui16"}}
	_{{.Index}} := {{.GoType}}(pbreq.Arg{{.Index}})
	{{- else if eq .IdlType "seq"}}
		{{- if .Key.IsStruct}}

	var _{{.Index}} []*idldata.{{.Key.GoType}}
	for _,v := range pbreq.Arg{{.Index}}{
		if v != nil {
			tobj := &idldata.{{.Key.GoType}}{}
			tobj.ParseFromPb(v)
			_{{.Index}} = append(_{{.Index}}, tobj)
		}
	}
		{{- else}}

	var _{{.Index}} []{{.Key.GoType}}
	for _,v := range pbreq.Arg{{.Index}}{
		_{{.Index}} = append(_{{.Index}}, {{.Key.GoType}}(v))
	}
		{{- end}}
	{{- else if eq .IdlType "set"}}
	var _{{.Index}} map[{{.Key.GoType}}]bool
	if pbreq.Arg{{.Index}} != nil {
		_{{.Index}} = make(map[{{.Key.GoType}}]bool)
	}
	for _,v := range pbreq.Arg{{.Index}}{
		_{{.Index}}[{{.Key.GoType}}(v)]=true
	}
	{{- else if eq .IdlType "dict"}}
		{{- if .Value.IsStruct}}
	var _{{.Index}} map[{{.Key.GoType}}]*idldata.{{.Value.GoType}}
	if pbreq.Arg{{.Index}} != nil {
		_{{.Index}} = make(map[{{.Key.GoType}}]*idldata.{{.Value.GoType}})
	}
	for k,v := range pbreq.Arg{{.Index}}{
		if v != nil {
			temp := &idldata.{{.Value.GoType}}{}
			temp.ParseFromPb(v)
			_{{.Index}}[k]=temp
		}
	}
		{{- else}}
	var _{{.Index}} map[{{.Key.GoType}}]{{.Value.GoType}}
	if pbreq.Arg{{.Index}} != nil {
		_{{.Index}} = make(map[{{.Key.GoType}}]{{.Value.GoType}})
	}
	for k,v := range pbreq.Arg{{.Index}}{
		_{{.Index}}[k]= {{.Value.GoType}}(v)
	}
		{{- end}}
	{{- else if .IsStruct}}
	var _{{.Index}} *idldata.{{.GoType}}
	if pbreq.Arg{{.Index}} != nil {
		_{{.Index}} = &idldata.{{.GoType}}{}
		_{{.Index}}.ParseFromPb(pbreq.Arg{{.Index}})
	}
	{{- else if .IsEnum}}
	_{{.Index}} := idldata.{{.GoType}}(pbreq.Arg{{.Index}})
	{{- else}}
	_{{.Index}} := pbreq.Arg{{.Index}}
	{{- end}}
	{{- end}}
	{{- end}}
	
	{{- if isupper .Name }}
	pbret := &pbdata.{{$sn}}_{{$fcn}}Ret{}
	{{- else }}
	pbret := &pbdata.{{$sn}}{{$fcn}}Ret{}
	{{- end }}
	defer func() {
		if p := recover(); p != nil {
			if pbret.Ctx == nil {
				pbret.Ctx = &pbdata.Context{}
			}
			pbret.Ctx.Info = append(pbret.Ctx.Info, &pbdata.KeyValue{Key: "call_trace", Value: string(debug.Stack())})
			pbret.Ctx.Info = append(pbret.Ctx.Info, &pbdata.KeyValue{Key: "error_info", Value: fmt.Sprint(p)})
			resp, _ = proto.Marshal(pbret)
			panic(rpcerr.RpcPanicInfo{Info: p, Pkg: resp})
		}
	}()
	{{- if ne .RetType.IdlType "void"}}
	ret, err := sb.srvImpl.{{$fcn}}(ctx{{- range $index,$elem := .Arguments}}
{{- print ", "}}
{{- if ne $elem.IdlType "void" }}_{{$elem.Index}}{{- end}}
{{- end}})
	{{- else}}
	err = sb.srvImpl.{{$fcn}}(ctx{{- range $index,$elem := .Arguments}}
{{- print ","}}
{{- if ne $elem.IdlType "void" }}_{{$elem.Index}}{{- end}}
{{- end}})
	{{end}}

	{{- if not .IsOneway }}

	//构造返回值 
	{{- if ne .RetType.IdlType "void"}}
	{{- if eq .RetType.IdlType "i8" "i16"}}
	pbret.Ret1 = int32(ret)
	{{- else if eq .RetType.IdlType "ui8" "ui16"}}
	pbret.Ret1 = uint32(ret)
	{{- else if eq .RetType.IdlType "set"}}
	for k, _ := range ret {
		pbret.Ret1 = append(pbret.Ret1, {{.RetType.Key.GoType}}(k))
	}
	{{- else if eq .RetType.IdlType "seq"}}
	for _,v := range ret {
		{{- if .RetType.Key.IsStruct}}
		pbret.Ret1 = append(pbret.Ret1, v.SerializeToPb())
		{{- else}}
		pbret.Ret1 = append(pbret.Ret1, {{.RetType.Key.GoType}}(v))
		{{- end}}
	}
	{{- else if eq .RetType.IdlType "dict"}}
	if pbret.Ret1 == nil{
		pbret.Ret1 = make(map[{{.RetType.Key.GoType}}]{{if .RetType.Value.IsStruct}}*pbdata.{{end}}{{.RetType.Value.GoType}})
	}
	for k,v := range ret {
		{{- if .RetType.Value.IsStruct}}
		pbret.Ret1[k] = v.SerializeToPb()
		{{- else}}
		pbret.Ret1[k] = {{.RetType.Value.GoType}}(v)
		{{- end}}
	}
	{{- else if .RetType.IsStruct}}
	if ret != nil {
		pbret.Ret1 = ret.SerializeToPb()
	}
	{{- else if .RetType.IsEnum}}
	pbret.Ret1 = pbdata.{{.RetType.GoType}}(ret)
	{{else}}
	pbret.Ret1 = ret
	{{- end}}
	if err != nil {
		if pbret.Ctx == nil {
			pbret.Ctx = &pbdata.Context{}
		}
		pbret.Ctx.Info = append(pbret.Ctx.Info, &pbdata.KeyValue{Key: "error_info", Value: err.Error()})
	}
	{{end}}

	{{- if ne .RetType.IdlType "void" }}
	resp, _ = proto.Marshal(pbret)
	{{- end }}
	{{- end}}
	return
}
{{end}}
`
	gStubPath = "stub"
)

var (
	stubtp *template.Template
)

func init() {
	temptp, err := template.New("stub").Funcs(funcsMap).Parse(stubLetter)
	if err != nil {
		fmt.Printf("%v\n", err)
		panic(fmt.Sprintf("init stub letter error %v !!!!", err))
	}
	temptp, err = temptp.Parse(funcletter)
	if err != nil {
		panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
	}

	stubtp, err = temptp.Parse(typeletter)
	if err != nil {
		panic(fmt.Sprintf("init proxy letter error %v !!!!", err))
	}
}

func StubGenFile(idlname string, gen *Gen) error {
	if gen == nil {
		return errors.New("gen idl name info error !!!!")
	}

	if stubtp == nil {
		panic("stub template impl error read nil value  !!! ")
	}

	//service stub 和 impl 文件放在一起
	//if PathExits(gStubPath) == false {
	//	os.Mkdir(gStubPath, 765)
	//}
	//
	//err := os.Chdir(gStubPath)
	//if err != nil {
	//	fmt.Printf("change to impl dir error %v dir %s \n", err, gProxyPath)
	//	return err
	//}
	//
	//defer os.Chdir("../")

	idlpackagename = idlname
	defer func() {
		idlpackagename = ""
	}()

	//检测文件删了重写
	ifile := strings.ToLower(gen.Name) + "_stub.go"
	if FileExits(ifile) {
		//存在的话删了重新生成
		err := os.Remove(ifile)
		fmt.Printf("delete %s stub file to rewrite %s !!! \n", gen.Name, ifile)
		if err != nil {
			fmt.Printf("delete %s impl file error %v !!! \n", gen.Name, err)
			return err
		}
	}

	//打开文件
	filehanle, err := os.OpenFile(ifile, os.O_WRONLY|os.O_CREATE, 0765)
	if err != nil {
		return err
	}

	defer func() {
		filehanle.Close()
	}()

	err = stubtp.Execute(filehanle, gen)
	if err != nil {
		fmt.Printf("generate imple file error %v\n", err)
		return err
	}

	return nil
}
